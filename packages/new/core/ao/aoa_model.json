{
    "lists": {
        "modelsTask": {
            "id": "id",
            "getList": "getModels",
            "deleteList": "deleteModel",
            "columns": {
                "app_label": {
                    "title": "Application",
                    "width": 250
                },
                "model_name": {
                    "title": "Name",
                    "width": 250
                }
            },
            "actions": [
                {
                    "title": "Refresh",
                    "icon": "refresh",
                    "mini": true,
                    "command": {
                        "type": "standard",
                        "call": "refresh"
                    }
                },
                {
                    "title": "Create",
                    "icon": "add",
                    "mini": true,
                    "command": {
                        "type": "task",
                        "call": "/aoa/ObjectTask",
                        "title": "New object",
                        "params": {
                            "object": "aoa_model",
                            "form": "modelTask"
                        }
                    }
                },
                {
                    "title": "Open",
                    "icon": "view",
                    "mini": true,
                    "command": {
                        "type": "task",
                        "call": "/aoa/ObjectTask",
                        "title$": "`Model ${$listRow.model_name}`",
                        "params": {
                            "object": "aoa_model",
                            "form": "modelTask",
                            "id$": "$listRow.id"
                        }
                    },
                    "disabled$": "!$listRow"
                },
                {
                    "title": "Delete",
                    "icon": "delete",
                    "mini": "true",
                    "command": {
                        "type": "standard",
                        "call": "delete"
                    },
                    "confirm": {
                        "message$": "`Delete model ${$listRow.model_name}?`",
                        "yes": "Yes",
                        "no": "No"
                    },
                    "disabled$": "!$listRow"
                }
            ]
        }
    },
    "forms": {
        "modelTask": {
            "comment": "Model definition JSON",
            "className": "task-panel",
            "style": {
                "height": "100%",
                "overflow": "hidden",
                "display": "flex",
                "flexDirection": "column"
            },
            "$": {
                "@panel": {
                    "className": "horizontal",
                    "style": {
                        "padding": "8px 8px 8px 8px"
                    },
                    "$": {
                        ".btnSave": {
                            "label": "Save",
                            "control": "Button",
                            "controlProps": {
                                "color": "primary"
                            },
                            "action": [
                                {
                                    "js": "context.j = JSON.parse(mem.json);"
                                },
                                {
                                    "js": "backend.post('/aoa/execObjectMethod', {object: 'aoa_model', method: 'saveModel', params: {...mem.model, definition: context.j}}).then((r)=>{mem.model.id=r.id; context.modified=false; setTaskTitle(`${_('Model')} ${mem.model.model_name}`)})"
                                }
                            ],
                            "readOnly$": "!context.modified"
                        },
                        ".btnApply": {
                            "label": "Apply",
                            "control": "Button",
                            "controlProps": {
                                "color": "primary",
                                "style": {
                                    "textTransform": "none"
                                }
                            },
                            "action": [
                                {
                                    "js": "return backend.post('/aoa/execObjectMethod', {object: 'aoa_model', method: 'sqlMigrations', params: {app_label: mem.model.app_label, model_name: mem.model.model_name, collect_sql: true}}).then((r)=>{context.migrationSql=r;})"
                                },
                                {
                                    "js": "frontend.dialog({object: 'aoa_model', form: 'applyMigrationDialog', params: {app_label: mem.model.app_label, model_name: mem.model.model_name, migrationSql: context.migrationSql}})"
                                }
                            ],
                            "readOnly$": "context.modified"
                        }
                    }
                },
                "@form": {
                    "className": "vertical",
                    "style": {
                        "flex": 1,
                        "overflow": "hidden",
                        "paddingTop": "4px"
                    },
                    "$": {
                        "model": {
                            "className": "horizontal",
                            "style": {
                                "paddingLeft": "4px"
                            },
                            "$": {
                                "app_label": {
                                    "label": "Application",
                                    "control": "TextEdit",
                                    "style": {
                                        "width": "280px"
                                    },
                                    "required": true,
                                    "actions": {
                                        "onChange": {
                                            "name": "onModified"
                                        }
                                    }
                                },
                                "model_name": {
                                    "label": "Model Name",
                                    "control": "TextEdit",
                                    "style": {
                                        "width": "570px"
                                    },
                                    "required": true,
                                    "actions": {
                                        "onChange": {
                                            "name": "onModified"
                                        }
                                    }
                                }
                            }
                        },
                        "@json": {
                            "style": {
                                "height": "100%"
                            },
                            "$": {
                                "json": {
                                    "style": {
                                        "height": "100%",
                                        "overflow": "hidden"
                                    },
                                    "control": "AceEditor",
                                    "controlProps": {
                                        "context$": "(()=>{context.ctxAce=context.ctxAce||{}; return context.ctxAce;})()",
                                        "mode": "json"
                                    },
                                    "actions": {
                                        "onChange": {
                                            "name": "onModified"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            "actions": {
                "onTaskCreated": [
                    {
                        "js": "return task.params.id && backend.post('/aoa/execObjectMethod', {object: 'aoa_model', method: 'getModel', params: {id: task.params.id}}).then((r)=>{mem.model = r;})"
                    },
                    {
                        "js": "!task.params.id && (()=>{mem.model={}})()"
                    },
                    {
                        "js": "mem.json = JSON.stringify(mem.model?.definition||{}, null, 4);"
                    }
                ],
                "onModified": {
                    "js": "if (!context.modified){context.modified=true; forceUpdate();}",
                    "disableUpdate": false
                }
            }
        },
        "applyMigrationDialog": {
            "title": "Apply Migration",
            "className": "vertical",
            "dialogStyle": {
                "width": "900px",
                "height": "600px"
            },
            "style": {
                "overflow": "hidden",
                "height": "100%"
            },
            "$": {
                "@form": {
                    "style": {
                        "overflowY": "hidden",
                        "flexGrow": 1
                    },
                    "$": {
                        "migrationSql": {
                            "style": {
                                "height": "100%",
                                "overflow": "hidden"
                            },
                            "control": "AceEditor",
                            "controlProps": {
                                "context$": "(()=>{context.ctxAce=context.ctxAce||{}; return context.ctxAce;})()",
                                "mode": "sql"
                            },
                            "actions": {
                                "xonChange": {
                                    "name": "onModified"
                                }
                            }
                        }
                    }
                },
                "@buttons": {
                    "className": "horizontal",
                    "style": {
                        "flexDirection": "row-reverse"
                    },
                    "$": {
                        ".btnAppy": {
                            "label": "Apply",
                            "control": "Button",
                            "controlProps": {
                                "color": "primary",
                                "variant": "contained"
                            },
                            "action": [
                                {
                                    "js": "return backend.post('/aoa/execObjectMethod', {object: 'aoa_model', method: 'sqlMigrations', params: {app_label: params.app_label, model_name: params.model_name, collect_sql: false}}).then((r)=>{context.applyResult=r;})"
                                },
                                {
                                    "js": "actions.close();",
                                    "disableUpdate": true
                                }
                            ]
                        },
                        ".btnCancel": {
                            "label": "Cancel",
                            "control": "Button",
                            "controlProps": {
                                "color": "primary"
                            },
                            "action": {
                                "js": "actions.close();",
                                "disableUpdate": true
                            }
                        }
                    }
                }
            },
            "actions": {
                "onDialogCreated": [
                    {
                        "js": "mem.migrationSql = params.migrationSql.join('\\n');"
                    }
                ]
            }
        }
    },
    "js": {},
    "methods": {
        "getModels": {
            "sql": {},
            "script": {
                "py": "from beflex.aoa.models import AModel\n\ndata = []\n\nfor m in AModel.objects.all():\n    data.append({\n        'id': m.id.__str__(),\n        'app_label': m.app_label,\n        'model_name': m.model_name\n    })"
            }
        },
        "saveModel": {
            "script": {
                "py": "from beflex.aoa.models import AModel\n\nif parameters.get('id'):\n    model = AModel.objects.get(id=parameters['id'])\nelse:\n    model = AModel()\n    \nmodel.app_label = parameters.get('app_label')\nmodel.model_name = parameters.get('model_name')\nmodel.definition = parameters.get('definition')\n\nmodel.save()\n\ndata = {\n    'id': model.id.__str__()\n}"
            }
        },
        "getModel": {
            "script": {
                "py": "from beflex.aoa.models import AModel\n\nif parameters.get('id'):\n    model = AModel.objects.get(id=parameters['id'])\nelif parameters.get('model_name'):\n    model = AModel.objects.get(model_name=parameters['model_name'])\n\ndata = {\n    'id': model.id.__str__(),\n    'app_label': model.app_label,\n    'model_name': model.model_name,\n    'definition': model.definition\n}"
            }
        },
        "deleteModel": {
            "script": {
                "py": "from beflex.aoa.models import AModel\n\nAModel.objects.get(id=parameters['id']).delete()"
            }
        },
        "old_makeMigrations": {
            "script": {
                "py": "from django.db import migrations, models\n\nmodel = AO.aoa_model.getModel(model_name=parameters['model_name'])\n\nmodel_fields = model['definition']\n\ndef field_declaration(definition):\n    fields = {\n        'UUIDField': models.UUIDField(),\n        'CharField': models.CharField()\n    }\n    return fields[definition['type']]\n\ndef generate_migration(model_name, fields):\n    migration = migrations.Migration(\n        f'amodel_{model_name.lower()}',\n        'dynamic_model',\n    )\n    \n    migration.operations = [\n        migrations.CreateModel(\n            name=model_name,\n            fields=[\n                (field_name, field_declaration(field_definition))\n                for field_name, field_definition in model_fields.items()\n            ]\n        )\n    ]\n    \n    \n    return migration\n\nmigration = generate_migration(parameters['model_name'], model_fields)\n\nfrom django.db.migrations.writer import MigrationWriter\nmw = MigrationWriter(migration)\ndata = mw.as_string()\n#raise UserException(json.dumps(model['definition'], indent=4))"
            }
        },
        "test": {
            "script": {
                "py": "from django.db import migrations, models\n#from django.db.migrations.writer import MigrationWriter\nfrom django.db import connections\nfrom django.db.migrations.state import ProjectState, ModelState\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.conf import settings\n\n\napp_label = parameters.get('app_label')\ncollect_sql=True\n\nmodel1 = AO.aoa_model.getModel(app_label='loans', model_name=parameters.get('model_name'))\n\nconnection = connections[settings.APPS_DB.get(app_label)]\n\nmigration1 = AO.aoa_model.generateMigrations(model=model1)\n\ndef init_state(migration):\n    state = ProjectState()\n    for op in migration.operations:\n        op.allow_migrate_model = lambda app, model: True\n        op.state_forwards(app_label, state)\n\n    return state\n\nfrom_state = ProjectState()\nto_state = init_state(migration1)\n\nmd = MigrationAutodetector(\n    from_state, to_state,\n)\nchanges = md._detect_changes()\nprint('changes', changes['loans'][0].operations)\n\nmclass = to_state.apps.get_model(app_label, 'product')\nprint('mclass', mclass._meta.indexes)\n\nwith connection.schema_editor(collect_sql=collect_sql) as schema_editor:\n\n    def apply_migration(app_label, migration, s1, s2):\n        for op in migration.operations:\n            op.allow_migrate_model = lambda app, model: True\n            op.database_forwards(app_label, schema_editor, s1, s2)\n    \n    def apply_changes(changes):\n        for app_label, migrations in changes.items():\n            for migration in migrations:\n                for operation in migration.operations:\n                    print('  op', operation)\n                    operation.allow_migrate_model = lambda app, model: True\n                    operation.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    apply_changes(changes)\n    #apply_migration(migration1, state1, state2)\n    \n    data = schema_editor.collected_sql\n\n        \n        \n        \n        "
            }
        },
        "sqlMigrations": {
            "script": {
                "py": "from django.db.migrations.state import ProjectState, ModelState\nfrom django.db.migrations.autodetector import MigrationAutodetector\nfrom django.db import connections\nfrom django.conf import settings\n\napp_label = parameters.get('app_label')\nif app_label is None:\n    raise UserError('Invaid argument: app_label')\n\nif settings.APPS_DB.get(app_label) is None:\n    raise UserError(f'Application \"{app_label}\"\" is not connected to database. Check settings.')\n    \nconnection = connections[settings.APPS_DB.get(app_label)]\n#app_label = 'dummy'\n\ncollect_sql = parameters['collect_sql']\n\nmodel = AO.aoa_model.getModel(app_label=parameters['app_label'], model_name=parameters['model_name'])\nmodel_inspected = AO.aoa_model.inspectModel(app_label=parameters['app_label'], model_name=parameters['model_name'])\n\napp_label = model['app_label']\n\nfrom_migration = None\nif model_inspected is not None:\n    from_migration = AO.aoa_model.generateMigration(model=model_inspected)\nto_migration = AO.aoa_model.generateMigration(model=model)\n\n\ndef migration_to_state(migration):\n    state = ProjectState()\n    for op in migration.operations:\n        op.allow_migrate_model = lambda app, model: True\n        op.state_forwards(app_label, state)\n        #print('state_op', op)\n        \n    return state\n\nif from_migration is not None:\n    from_state = migration_to_state(from_migration)\nelse:\n    from_state = ProjectState()\n    \nto_state = migration_to_state(to_migration)\n\nchanges = MigrationAutodetector(from_state, to_state.clone(),)._detect_changes()\n\nwith connection.schema_editor(collect_sql=collect_sql) as schema_editor:\n\n    for app_label, migrations in changes.items():\n        for migration in migrations:\n            for operation in migration.operations:\n                operation.allow_migrate_model = lambda app, model: True\n                operation.database_forwards(app_label, schema_editor, from_state, to_state)\n\n    if collect_sql:\n        data = schema_editor.collected_sql\n    else:\n        data = ['Migrations applyed',]\n"
            }
        },
        "defineColumn": {
            "script": {
                "py": "from django.db import models\nfrom beflex.db import RawJSONField\n\non_delete={\n    'cascade': models.CASCADE,\n    'nothing': models.DO_NOTHING\n}\n\ndef define_column(definition):\n    if not isinstance(definition, dict):\n        raise UserError('Invalid parameter: column definiton')\n    \n    fields = {\n        'AutoField': models.AutoField,\n        'UUIDField': models.UUIDField,\n        'CharField': models.CharField,\n        'ForeignKey': models.ForeignKey,\n        'BooleanField': models.BooleanField,\n        'RawJSONField': RawJSONField,\n        'IntegerField': models.IntegerField,\n        'DateTimeField': models.DateTimeField,\n        'DecimalField': models.DecimalField\n    }\n    field_class = fields.get(definition['type'])\n    if field_class is None:\n        raise UserException('Column type {type} is not supported'.format(type=definition['type']))\n        \n    kwargs = {\n        'max_length': definition.get('max_length', None),\n        'primary_key': definition.get('primary_key', False),\n        'unique': definition.get('unique', False),\n        'null': definition.get('null', True)\n    }\n    \n    args = []\n    if field_class == models.ForeignKey:\n        to = definition['to']\n        if to ==\"self\":\n            to = 'self'\n            \n        args.append(to)\n        args.append(on_delete[definition.get('on_delete', models.DO_NOTHING)])\n    elif field_class == models.DecimalField:\n        kwargs['max_digits'] = definition.get('max_digits')\n        kwargs['decimal_places'] = definition.get('decimal_places')\n        \n    return field_class(*args, **kwargs)\n\ndata = define_column(parameters['definition'])\n"
            },
            "sql": {}
        },
        "defineConstraint": {
            "script": {
                "py": "from django.db import models\n\nconstraint_classes = {\n    'unique': models.UniqueConstraint\n}\n\ndef define_constraint(name, definition):\n    constraint_class = constraint_classes.get(definition['type'])\n    if constraint_class is None:\n        raise UserException('Constraint type {type} is not supported'.format(type=definition['type']))\n    \n    kwargs = {\n        'name': name\n    }\n    \n    if 'columns' in definition:\n        kwargs['fields'] = definition['columns']\n    \n    constraint = constraint_class(**kwargs)\n    \n    return constraint\n    \ndata = define_constraint(parameters['name'], parameters['definition'])"
            }
        },
        "generateMigration": {
            "script": {
                "py": "from django.db import migrations\nfrom django.db import models\n\n\ndef make_index_name(app_label, model_name, index_name):\n    return app_label+'_'+model_name+'_'+index_name+'_idx';\n\ndef make_constraint_name(app_label, model_name, index_name):\n    return app_label+'_'+model_name+'_'+index_name+'_crt';\n\ndef generate_migration(model):\n    app_label = model['app_label']\n    model_name = model['model_name']\n    model_columns = model['definition']['columns']\n    \n    migration = migrations.Migration(\n        model_name,\n        app_label,\n    )\n    migration.initial = True\n    \n    columns = [\n        (column_name, AO.aoa_model.defineColumn(definition=column_definition))\n        for column_name, column_definition in model_columns.items()\n    ]\n    \n    migration.operations = [\n        migrations.CreateModel(\n            name=model_name,\n            fields=columns\n        )\n    ]\n    \n\n    model_indexes = model['definition'].get('indexes', {})\n    model_constraints = model['definition'].get('constraints', {})\n    \n    for index_name, index_definition in model_indexes.items():\n        migration.operations.append(migrations.AddIndex(\n            model_name=model_name,\n            index=models.Index(fields=index_definition.get('columns', []), name=make_index_name(app_label, model_name, index_name)),\n        ))\n\n    for constraint_name, constraint_definition in model_constraints.items():\n        constraint = AO.aoa_model.defineConstraint(\n            name        = make_constraint_name(app_label, model_name, constraint_name),\n            definition  = constraint_definition\n        )\n        \n        migration.operations.append(migrations.AddConstraint(\n            model_name, constraint\n        ))\n\n\n    return migration\n    \ndata = generate_migration(parameters['model'])\n"
            },
            "sql": {}
        },
        "inspectModel": {
            "script": {
                "py": "from django.db import connections\nimport re\n\napp_label  = parameters['app_label']\nmodel_name = parameters['model_name']\n\ntable_name = app_label+'_'+model_name\nconnection = connections['default']\n\nmodel = None\n\ndef extract_index_name(app_label, model_name, index_name):\n    # <app_label>_<model_name>_<index_name>_idx\n    RE = \"^{app_label}_{model_name}_(?P<index_name>[a-z]+)_idx$\".format(app_label=app_label, model_name=model_name)\n    m = re.match(RE, index_name)\n    if m:\n        return m.group('index_name')\n    return None\n\ndef extract_constraint_name(app_label, model_name, constraint_name):\n    # <app_label>_<model_name>_<constraint_name>_crt\n    RE = \"^{app_label}_{model_name}_(?P<constraint_name>[a-z]+)_crt$\".format(app_label=app_label, model_name=model_name)\n    m = re.match(RE, constraint_name)\n    if m:\n        return m.group('constraint_name')\n    return None\n    \ndef extract_app_table_name(real_table_name):\n    app_table = real_table_name.split('_')\n    \n\nwith connection.cursor() as cursor:\n    tables = connection.introspection.get_table_list(cursor)\n    table = next(filter(lambda x: x.name==table_name, tables), None)\n    \n    if table is not None:\n        model = {\n            'app_label': app_label,\n            'model_name': model_name,\n            'definition': {\n                'columns': {}\n            }\n        }\n        table_description = connection.introspection.get_table_description(\n            cursor, table_name\n        )\n        \n        primary_key_columns = (connection.introspection.get_primary_key_columns(cursor, table_name) or [])\n        primary_key_column = (\n            primary_key_columns[0]\n            if len(primary_key_columns) == 1\n            else None\n        )\n        \n        constraints = connection.introspection.get_constraints(cursor, table_name)\n        print('constraints', json.dumps(constraints, indent=4))\n        \n        unique_columns = [\n            c[\"columns\"][0]\n            for c in constraints.values()\n            if c[\"unique\"] and len(c[\"columns\"]) == 1\n        ]\n        \n        foreign_key_columns = {\n            v['columns'][0]: v['foreign_key']\n            for k, v in constraints.items() if v['foreign_key'] and len(v['foreign_key'])==2\n        }\n        \n        indexes = {\n            name: details \n            for name, details in constraints.items() if not details['unique'] and not details['primary_key']\n        }\n        \n\n        for field in table_description:\n            print(field)\n            model_field_name = field.name\n            \n            if field.type_code == 114:\n                # Postgres json field\n                field_type = 'RawJSONField'\n            else:\n                field_type = connection.introspection.get_field_type(field.type_code, field)\n            \n            field_definition = {'type': field_type}\n            \n            if field.null_ok:\n                field_definition['null'] = True\n            \n            if field.name == primary_key_column:\n                field_definition['primary_key'] = True\n            elif field.name in unique_columns:\n                field_definition['unique'] = True\n            \n            if field.name in foreign_key_columns:\n                field_definition['type'] = 'ForeignKey'\n                # foreign key real table name is formatted as app_table, so we need only table name\n                field_definition['to'] = foreign_key_columns[field.name][0].split('_')[1]\n                field_definition['on_delete'] = 'nothing'\n                model_field_name = field.name[:-len(foreign_key_columns[field.name][1])-1]\n            \n            if field_type=='CharField' and (size := int(field.display_size)) and size > 0:\n                field_definition['max_length'] = size\n                \n            if field.precision is not None:\n                field_definition['max_digits'] = field.precision\n                \n            if field.scale is not None:\n                field_definition['decimal_places'] = field.scale\n\n            \"\"\"\n            if field.name=='id' and field_type=='AutoField':\n                # skip auto generated column\n                continue\n            \"\"\"\n            \n            model['definition']['columns'][model_field_name] = field_definition\n            \n        def extract_index_columns(columns):\n            index_columns = []\n            for column in columns:\n                if column in foreign_key_columns:\n                    index_columns.append(column.split('_')[0])\n                else:\n                    index_columns.append(column)\n            return index_columns\n            \n        model['definition']['indexes'] = {}\n        for index_name, index_value in indexes.items():\n            local_index_name = extract_index_name(app_label, model_name, index_name)\n            if local_index_name is not None:\n                model['definition']['indexes'][local_index_name] = {\n                    'columns': extract_index_columns(index_value['columns'])\n                }\n                \n        model['definition']['constraints'] = {}\n        for constraint_name, constraint_value in constraints.items():\n            local_constraint_name = extract_constraint_name(app_label, model_name, constraint_name)\n            print('%s->%s' % (constraint_name, local_constraint_name))\n            if local_constraint_name is not None:\n                if constraint_value['unique']:\n                    model['definition']['constraints'][local_constraint_name] = {\n                        'type': 'unique',\n                        'columns': extract_index_columns(constraint_value['columns'])\n                    }\n        \n#print(json.dumps(model['definition'], indent=4))\ndata = model\n"
            },
            "sql": {}
        }
    },
    "references": {}
}